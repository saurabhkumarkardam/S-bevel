---
apiVersion: batch/v1
kind: Job
metadata:
  name: substrate-genesis-pre-hook
  namespace: {{ .Release.Namespace }}
  annotations:
    "helm.sh/hook": post-install
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": "before-hook-creation"
  labels:
    app.kubernetes.io/name: pre-install-hook
    app.kubernetes.io/component: keygen
    app.kubernetes.io/namespace: {{ .Release.Namespace }}
    app.kubernetes.io/release: {{ .Release.Name }}
    app.kubernetes.io/managed-by: helm
spec:
  backoffLimit: 1
  completions: 1
  template:
    metadata:
      labels:
        app.kubernetes.io/name: pre-install-hook
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      serviceAccountName: {{ $.Values.global.serviceAccountName }}
      restartPolicy: "OnFailure"
      containers:
        - name: sup-keygen
          image: {{ $.Values.node.image }}
          securityContext:
            runAsUser: 0
          volumeMounts:
            - name: scripts-volume
              mountPath: /scripts/bevel-vault.sh
              subPath: bevel-vault.sh
            - name: package-manager
              mountPath: /scripts/package-manager.sh
              subPath: package-manager.sh
          env:
          - name: VAULT_ADDR
            value: {{ $.Values.global.vault.address }}
          - name: KUBERNETES_AUTH_PATH
            value: {{ $.Values.global.vault.authPath }}
          - name: VAULT_APP_ROLE
            value: {{ $.Values.global.vault.role }}
          - name: MOUNT_PATH
            value: "/certcheck"
          - name: CERTS_SECRET_PREFIX
            value: {{ .Values.global.vault.secretPrefix }}        
          command: ["bash", "-c"]
          args:
            - |
                #!/usr/bin/env bash
                {{- if ne $.Values.node.image "docker.io/paritytech/substrate-playground-template-node-template:latest" }}
                  . /scripts/package-manager.sh
                  # Define the packages to install
                  packages_to_install="jq curl"
                  install_packages "$packages_to_install"

                  # Check if jq is installed
                  if ! command -v jq &> /dev/null; then
                    # jq is not installed, download it
                    cd ~
                    curl -k -L -o jq https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64
                    chmod +x jq
                    export PATH="$PATH:$HOME"
                  else
                    echo "jq is already installed via package-manager.sh."
                  fi

                  # Download the latest version of kubectl
                  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
                  # Make the kubectl binary executable
                  chmod +x kubectl
                  # Move the binary to a directory in your PATH
                  mv kubectl /usr/local/bin/
                  # Verify installation
                  kubectl version --client
                  
                  if [[ $? > 0 ]]
                  then
                    # download jq
                    cd ~;
                    curl -k -L -o jq https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64;
                    chmod +x jq;
                    export PATH=$PATH:.;
                  else
                    echo "jq and curl was installed using apt-get."
                  fi;
                {{- end }}

                # Check if the vault type is HashiCorp
{{- if eq .Values.global.vault.type "hashicorp" }}
                # Source the script containing vault-related functions
                . /scripts/bevel-vault.sh

                echo "Generate a customize token."
                vaultBevelFunc "init"
                
                # Function to safely write keys
                safeWriteSecret() {
                  local key="$1"
                  local payload_json="$2"
                  
                  # Read secret from vault
                  vaultBevelFunc "readJson" "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/${key}"
                  # Check if secrets are available in the vault
                  if [ "$SECRETS_AVAILABLE" == "yes" ]
                    then
                      # Extract secrets from JSON response
                      local node_id=$(echo ${VAULT_SECRET} | jq -r '.["node_id"]')
                      local node_key=$(echo ${VAULT_SECRET} | jq -r '.["node_key"]')
                      local aura_seed=$(echo ${VAULT_SECRET} | jq -r '.["aura_seed"]')
                      local aura_addr=$(echo ${VAULT_SECRET} | jq -r '.["aura_addr"]')
                      local grandpa_seed=$(echo ${VAULT_SECRET} | jq -r '.["grandpa_seed"]')
                      local grandpa_addr=$(echo ${VAULT_SECRET} | jq -r '.["grandpa_addr"]')
                      local aura_file_b64=$(echo ${VAULT_SECRET} | jq -r '.["aura_file_b64"]' | base64 -d)
                      local grandpa_file_b64=$(echo ${VAULT_SECRET} | jq -r '.["grandpa_file_b64"]' | base64 -d)
                      
                      # Check if Kubernetes secret exists, if not, create one
                      if ! kubectl get secret substrate-node-validator-${i}-keys --namespace {{ .Release.Namespace }} &> /dev/null; then                      
                        kubectl create secret generic substrate-node-validator-${i}-keys --namespace {{ .Release.Namespace }} \
                        --from-literal=node_id=${node_id} \
                        --from-literal=node_key=${node_key} \
                        --from-literal=aura_seed=${aura_seed} \
                        --from-literal=aura_addr=${aura_addr} \
                        --from-literal=grandpa_seed=${grandpa_seed} \
                        --from-literal=grandpa_addr=${grandpa_addr} \
                        --from-literal=aura_file_b64=${aura_file_b64}
                        --from-literal=grandpa_file_b64=${grandpa_file_b64}
                      fi
                  else
                    # Push data to vault
                    vaultBevelFunc 'write' "${VAULT_SECRET_ENGINE}/${VAULT_SECRET_PREFIX}/${key}" "${payload_json}"
                    rm nodePayload.json
                  fi
                }
{{- else }}
                safeWriteSecret() {
                  # Placeholder:
                  # - Implement code to fetch the keys if using any cloud-native service or platform different from HashiCorp to store the keys
                  # - After fetching the keys, create Kubernetes secrets from them
                  # - For guidance, refer to the code written for HashiCorp Vault for the same purpose
                  return 0
                }
{{- end }}
                
                command={{ $.Values.node.command }}
                
                for ((i=1; i<={{ $.Values.node.validatorCount }}; i++))
                do
                  echo "Generating nodekey for validator-$i"
                  node_id=$($command key generate-node-key --file node_key 2>&1)
                  
                  echo "Generate aura key for validator-$i"
                  $command key generate --scheme Sr25519 --output-type json >> auraKeygenOutput_validator$i.json
                  AURA_SEED=$(jq -r '.secretSeed' auraKeygenOutput_validator$i.json)
                  AURA_ADDR=$(jq -r '.ss58Address' auraKeygenOutput_validator$i.json)
                  
                  echo "Generate grandpa key for validator-$i"
                  $command key generate --scheme Ed25519 --output-type json >> grandpaKeygenOutput_validator$i.json
                  GRANDPA_SEED=$(jq -r '.secretSeed' grandpaKeygenOutput_validator$i.json)
                  GRANDPA_ADDR=$(jq -r '.ss58Address' grandpaKeygenOutput_validator$i.json)

                  {{- if eq .Values.node.type "member" }}
                    echo "Generate Account key for member/owner node"
                    $command key generate --scheme Sr25519 --output-type Json >> accKeygenOutput.json          
                    ACCOUNT_SEED=$(jq -r '.secretSeed' accKeygenOutput.json)
                    ACCOUNT_ADDR=$(jq -r '.ss58Address' accKeygenOutput.json)

                    echo "
                      {
                      \"data\": {
                      \"node_id\": \"$node_id\",
                      \"node_key\": \"$(cat node_key)\",
                      \"aura_seed\": \"$AURA_SEED\",
                      \"aura_addr\": \"$AURA_ADDR\",
                      \"grandpa_seed\": \"$GRANDPA_SEED\",
                      \"grandpa_addr\": \"$GRANDPA_ADDR\",
                      \"account_seed\": \"$ACCOUNT_SEED\",
                      \"account_addr\": \"$ACCOUNT_ADDR\",
                      \"account_file_b64\": \"$(cat accKeygenOutput.json | base64 -w 0)\",
                      \"aura_file_b64\": \"$(cat auraKeygenOutput_validator$i.json | base64 -w 0)\",
                      \"grandpa_file_b64\":\"$(cat grandpaKeygenOutput_validator$i.json | base64 -w 0)\"
                    }}" > finalJSON.json
                    secret_name="substrate-node-member-${i}-keys"
                  {{- else }}
                    echo "
                      {
                      \"data\": {
                      \"node_id\": \"$node_id\",
                      \"node_key\": \"$(cat node_key)\",
                      \"aura_seed\": \"$AURA_SEED\",
                      \"aura_addr\": \"$AURA_ADDR\",
                      \"grandpa_seed\": \"$GRANDPA_SEED\",
                      \"grandpa_addr\": \"$GRANDPA_ADDR\",
                      \"aura_file_b64\": \"$(cat auraKeygenOutput_validator$i.json | base64 -w 0)\",
                      \"grandpa_file_b64\":\"$(cat grandpaKeygenOutput_validator$i.json | base64 -w 0)\"
                    }}" > finalJSON.json
                    secret_name="substrate-node-validator-${i}-keys"
                  {{- end }}

                  if ! kubectl get secret "${secret_name}" --namespace {{ .Release.Namespace }} &> /dev/null; then
                    echo "creating secrets"
                    kubectl create secret generic "${secret_name}" --namespace {{ .Release.Namespace }} --from-file="substrate-node-keys"="finalJSON.json"
                  fi
                  
                  {{- if and (ne .Values.global.cluster.provider "minikube") (.Values.global.cluster.cloudNativeServices) }}
                    # If using any cloud-native service or platform different from HashiCorp to store the keys
                  {{- else }}
                    safeWriteSecret "${secret_name}" finalJSON.json
                  {{- end }}
                done
      volumes:
        - name: scripts-volume
          configMap:
            name: bevel-vault-script
            defaultMode: 0777
        - name: package-manager
          configMap:
            name: package-manager
