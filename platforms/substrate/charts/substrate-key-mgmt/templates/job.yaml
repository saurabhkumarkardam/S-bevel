##############################################################################################
#  Copyright Accenture. All Rights Reserved.
#
#  SPDX-License-Identifier: Apache-2.0
##############################################################################################

apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ $.Values.metadata.name }}"
  namespace: "{{ $.Values.metadata.namespace }}"
  labels:
    app: "{{ $.Values.metadata.name }}"
    app.kubernetes.io/name: "{{ $.Values.metadata.name }}"
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    {{- include "labels.custom" . | nindent 2 }}
spec:
  backoffLimit: 6
  template:
    metadata:
      labels:
        app: "{{ $.Values.metadata.name }}"
        app.kubernetes.io/name: "{{ $.Values.metadata.name }}"
        app.kubernetes.io/instance: {{ .Release.Name }}
        {{- include "labels.custom" . | nindent 2 }}
    spec:
      restartPolicy: OnFailure
      serviceAccountName: {{ $.Values.vault.serviceAccountName }}
      securityContext:
        fsGroup: 1000
      containers:
      - name: generate-cryptomaterials
        image: {{ $.Values.node.image }}
        imagePullPolicy: {{ $.Values.node.pullPolicy }}
        volumeMounts:
          - name: certcheck
            mountPath: /certcheck
          - name: package-manager
            mountPath: /scripts/package-manager.sh
            subPath: package-manager.sh
        env:
        - name: VAULT_ADDR
          value: {{ $.Values.vault.address }}
        - name: KUBERNETES_AUTH_PATH
          value: {{ $.Values.vault.authpath }}
        - name: VAULT_APP_ROLE
          value: {{ $.Values.vault.role }}
        - name: MOUNT_PATH
          value: "/certcheck"
        - name: CERTS_SECRET_PREFIX
          value: {{ .Values.vault.certsecretprefix }}        
        - name: PEER_NAME
          value: "{{ $.Values.node.name }}"
        command: ["bash", "-c"]
        args:
        - |-
            #!/usr/bin/env bash
            {{- if ne $.Values.node.image "docker.io/paritytech/substrate-playground-template-node-template:latest" }}
              . /scripts/package-manager.sh
              # Define the packages to install
              packages_to_install="jq curl"
              install_packages "$packages_to_install"
              # Download the latest version of kubectl
              curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

              # Make the kubectl binary executable
              chmod +x kubectl

              # Move the binary to a directory in your PATH
              mv kubectl /usr/local/bin/

              # Verify installation
              kubectl version --client

              # kubectl create namespace subs-new
              if [[ $? > 0 ]]
              then
              # download jq
              cd ~;
              curl -k -L -o jq https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64;
              chmod +x jq;
              export PATH=$PATH:.;
              else
              echo "jq and curl was installed using apt-get."
              fi;
            {{- end }}
            echo "Done saving keys in vault"

            command={{ $.Values.node.command }}

            echo "Generate nodekey"
            node_id=$($command key generate-node-key --file node_key 2>&1)

            echo "Generate aura key"
            $command key generate --scheme Sr25519 --output-type json >> auraKeygenOutput.json
            AURA_SEED=$(jq -r '.secretSeed' auraKeygenOutput.json)
            AURA_ADDR=$(jq -r '.ss58Address' auraKeygenOutput.json)

            echo "Generate grandpa key"
            $command key generate --scheme Ed25519 --output-type json >> grandpaKeygenOutput.json
            GRANDPA_SEED=$(jq -r '.secretSeed' grandpaKeygenOutput.json)
            GRANDPA_ADDR=$(jq -r '.ss58Address' grandpaKeygenOutput.json)

            {{- if eq .Values.node.type "member" }}
              echo "Generate Account key for member/owner node"
              $command key generate --scheme Sr25519 --output-type Json >> accKeygenOutput.json          
              ACCOUNT_SEED=$(jq -r '.secretSeed' accKeygenOutput.json)
              ACCOUNT_ADDR=$(jq -r '.ss58Address' accKeygenOutput.json)

              echo "
                {
                \"data\": {
                \"node_id\": \"$node_id\",
                \"node_key\": \"$(cat node_key)\",
                \"aura_seed\": \"$AURA_SEED\",
                \"aura_addr\": \"$AURA_ADDR\",
                \"grandpa_seed\": \"$GRANDPA_SEED\",
                \"grandpa_addr\": \"$GRANDPA_ADDR\",
                \"account_seed\": \"$ACCOUNT_SEED\",
                \"account_addr\": \"$ACCOUNT_ADDR\",
                \"account_file_b64\": \"$(cat accKeygenOutput.json | base64 -w 0)\",
                \"aura_file_b64\": \"$(cat auraKeygenOutput.json | base64 -w 0)\",
                \"grandpa_file_b64\":\"$(cat grandpaKeygenOutput.json | base64 -w 0)\"
              }}" > finalJSON.json
            {{- else }}
              echo "
                {
                \"data\": {
                \"node_id\": \"$node_id\",
                \"node_key\": \"$(cat node_key)\",
                \"aura_seed\": \"$AURA_SEED\",
                \"aura_addr\": \"$AURA_ADDR\",
                \"grandpa_seed\": \"$GRANDPA_SEED\",
                \"grandpa_addr\": \"$GRANDPA_ADDR\",
                \"aura_file_b64\": \"$(cat auraKeygenOutput.json | base64 -w 0)\",
                \"grandpa_file_b64\":\"$(cat grandpaKeygenOutput.json | base64 -w 0)\"
              }}" > finalJSON.json
            {{- end }}

            if ! kubectl get secret "${PEER_NAME}-substrate" --namespace {{ .Release.Namespace }} &> /dev/null; then
              echo "creating secrets"
              kubectl create secret generic "${PEER_NAME}-substrate" --namespace {{ .Release.Namespace }} --from-file="${PEER_NAME}-substrate-creds"="finalJSON.json"
            fi
            
            secret_data=$(kubectl get secret "substrate-substrate" --namespace gensub -o json | jq -r '.data["substrate-substrate-creds"]' | base64 -d)
            echo "secret_data: $secret_data"
            # Check if secret_data is empty or not
            if [ -n "$secret_data" ]; then
                echo "Parse aura_addr from decoded JSON"
                aura_addr=$(echo "$secret_data" | jq -r '.data.aura_addr')
                echo "aura_addr: $aura_addr"
            else
                echo "Error: Unable to retrieve data from Kubernetes secret."
            fi
            {{- if eq .Values.vault.type "hashicorp" }}
              vaultBevelFunc "init"
              vault_secret_key="${CERTS_SECRET_PREFIX}/${PEER_NAME}/substrate"
              vaultBevelFunc 'write' "${VAULT_ADDR}/v1/${vault_secret_key}" 'finalJSON.json'
            {{- end }}
      volumes:
        - name: certcheck
          emptyDir:
            medium: Memory
        - name: package-manager
          configMap:
            name: package-manager
