---
apiVersion: batch/v1
kind: Job
metadata:
  name: subs-node-pre-hook
  namespace: {{ .Release.Namespace }}
  annotations:
    "helm.sh/hook": pre-install
    "helm.sh/hook-weight": "0"
    "helm.sh/hook-delete-policy": "before-hook-creation"
  labels:
    app.kubernetes.io/name: pre-install-hook
    app.kubernetes.io/component: keygen
    app.kubernetes.io/namespace: {{ .Release.Namespace }}
    app.kubernetes.io/release: {{ .Release.Name }}
    app.kubernetes.io/managed-by: helm
spec:
  backoffLimit: 1
  completions: 1
  template:
    metadata:
      labels:
        app.kubernetes.io/name: pre-install-hook
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      serviceAccountName: {{ $.Values.global.serviceAccountName }}
      restartPolicy: "OnFailure"
      containers:
        - name: subs-new-node-keygen
          image: {{ $.Values.image.repository }}
          securityContext:
            runAsUser: 0
          volumeMounts:
            - name: package-manager
              mountPath: /scripts/package-manager.sh
              subPath: package-manager.sh
            # - name: scripts-volume
            #   mountPath: /scripts/bevel-vault.sh
            #   subPath: bevel-vault.sh
          # env:
          # - name: VAULT_ADDR
          #   value: {{ $.Values.global.vault.address }}
          # - name: KUBERNETES_AUTH_PATH
          #   value: {{ $.Values.global.vault.authPath }}
          # - name: VAULT_APP_ROLE
          #   value: {{ $.Values.global.vault.role }}
          # - name: MOUNT_PATH
          #   value: "/certcheck"
          # - name: CERTS_SECRET_PREFIX
          #   value: {{ .Values.global.vault.secretPrefix }}        
          command: ["bash", "-c"]
          args:
            - |

                #!/usr/bin/env bash

                . /scripts/package-manager.sh
                # Define the packages to install
                packages_to_install="jq curl bc base58 xxd"
                install_packages "$packages_to_install"
                
                # Check if jq is installed
                if ! command -v jq &> /dev/null; then
                    # jq is not installed, download it
                    cd ~
                    curl -k -L -o jq https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64
                    chmod +x jq
                    export PATH="$PATH:$HOME"
                else
                    echo "jq is already installed via package-manager.sh."
                fi
                    
                # Download the latest version of kubectl
                curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
                chmod +x kubectl
                mv kubectl /usr/local/bin/
                kubectl version --client
                
                if [[ $? > 0 ]]
                then
                    # download jq
                    cd ~;
                    curl -k -L -o jq https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64;
                    chmod +x jq;
                    export PATH=$PATH:.;
                else
                    echo "jq and curl was installed using apt-get."
                fi;

                generate_key() {
                    echo ">>>>>>>>>> 3 - generate_key <<<<<<<<<<"
                    local scheme="$1"
                    local output_file="$2"
                    $command key generate --scheme "$scheme" --output-type json >> "$output_file"
                }

                generate_nodekey() {
                    echo ">>>>>>>>>> 2 - generate_nodekey <<<<<<<<<<"
                    local node_type="$1"

                    local node_id="$($command key generate-node-key --file node_key 2>&1)"
                    
                    generate_key "Sr25519" "auraKeygenOutput.json"
                    local AURA_SEED=$(jq -r '.secretSeed' "auraKeygenOutput.json")
                    local AURA_ADDR=$(jq -r '.ss58Address' "auraKeygenOutput.json")
                    
                    generate_key "Ed25519" "grandpaKeygenOutput.json"
                    local GRANDPA_SEED=$(jq -r '.secretSeed' "grandpaKeygenOutput.json")
                    local GRANDPA_ADDR=$(jq -r '.ss58Address' "grandpaKeygenOutput.json")
                    
                    if [[ "$node_type" == "member" ]]; then
                        generate_key "Sr25519" "accKeygenOutput.json"
                        local ACCOUNT_SEED=$(jq -r '.secretSeed' "accKeygenOutput.json")
                        local ACCOUNT_ADDR=$(jq -r '.ss58Address' "accKeygenOutput.json")
                        
                        echo "{
                            \"data\": {
                                \"node_id\": \"$node_id\",
                                \"node_key\": \"$(cat node_key)\",
                                \"aura_seed\": \"$AURA_SEED\",
                                \"aura_addr\": \"$AURA_ADDR\",
                                \"grandpa_seed\": \"$GRANDPA_SEED\",
                                \"grandpa_addr\": \"$GRANDPA_ADDR\",
                                \"account_seed\": \"$ACCOUNT_SEED\",
                                \"account_addr\": \"$ACCOUNT_ADDR\",
                                \"account_file_b64\": \"$(cat accKeygenOutput.json | base64 -w 0)\",
                                \"aura_file_b64\": \"$(cat auraKeygenOutput.json | base64 -w 0)\",
                                \"grandpa_file_b64\": \"$(cat grandpaKeygenOutput.json | base64 -w 0)\"
                            }
                        }" > finalJSON.json
                    else
                        echo "{
                            \"data\": {
                                \"node_id\": \"$node_id\",
                                \"node_key\": \"$(cat node_key)\",
                                \"aura_seed\": \"$AURA_SEED\",
                                \"aura_addr\": \"$AURA_ADDR\",
                                \"grandpa_seed\": \"$GRANDPA_SEED\",
                                \"grandpa_addr\": \"$GRANDPA_ADDR\",
                                \"aura_file_b64\": \"$(cat auraKeygenOutput.json | base64 -w 0)\",
                                \"grandpa_file_b64\": \"$(cat grandpaKeygenOutput.json | base64 -w 0)\"
                            }
                        }" > finalJSON.json
                    fi
                    
                    if ! kubectl get secret "${secret_name}" --namespace "{{ .Release.Namespace }}" &> /dev/null; then
                        echo "creating secrets"
                        kubectl create secret generic "${secret_name}" --namespace "{{ .Release.Namespace }}" --from-file="substrate-node-keys"="finalJSON.json"
                    fi
                }

                # Function to add the node to Genesis
                add_node_to_genesis() {
                    echo "Inside add_node_to_genesis"
                    # chain_spec=$(kubectl get configmap "substrate-genesis" --namespace {{ .Release.Namespace }} -o json | jq -r '.data["genesis"]')
                    # echo "${chain_spec}" | base64 -d > ./genesisRaw.json

                    GENESIS=$(cat ./genesisRaw.json)
                    echo "GENESIS-1: $(echo "$GENESIS" | head -n 5)"

                    node_id=$(kubectl get secret "$secret_name" --namespace {{ .Release.Namespace }} -o json | jq -r '.data["substrate-node-keys"]' | base64 -d | jq -r '.data.node_id')
                    echo "node_id: $node_id"

                    base58=$(echo -n "$node_id" | base58 -d | xxd -p | tr -d '[:space:]' | tr '[:lower:]' '[:upper:]')
                    echo "base58: $base58"

                    arr_node_id=($(echo "$base58" | fold -w2))

                    i=1
                    for byte in "${arr_node_id[@]}"; do
                        echo ">>>> ${i} <<<<"
                        echo "byte: $byte"
                        GENESIS=$(echo "$GENESIS" | jq --arg byte "$(echo "obase=10; ibase=16; $byte" | bc)" '.genesis.runtime.nodeAuthorization.nodes[-1][0] += [($byte | tonumber)]')
                        ((i++))
                    done
                    echo "GENESIS-2: $(echo "$GENESIS" | head -n 5)"
                    echo " ########################### "
                    echo "GENESIS-3: $(echo "$GENESIS" | tail -n 30)"

                    mkdir certcheck
                    echo "$GENESIS" > certcheck/genesis.json
                    GENESIS=$($command build-spec --disable-default-bootnode --raw --chain certcheck/genesis.json)
                    echo "$GENESIS" > certcheck/genesis_raw.json
                    cat certcheck/genesis_raw.json | base64 -w0 > certcheck/genesis_base64

                    kubectl create configmap "substrate-genesis" --namespace {{ .Release.Namespace }} --from-file=genesis="${MOUNT_PATH}/genesis_base64" --from-file=sudoKeygenOutput="${MOUNT_PATH}/sudoKeygenOutput.json" --dry-run=client -o yaml | kubectl replace -f -
                    echo " ########################### done"
                    sleep 2m
                }
                
                echo ">>>>>>>>>> OUTSIDE <<<<<<<<<<"

                command="{{ $.Values.node.command }}"
                secret_name="substrate-node-{{ .Release.Name }}-keys"
                
                if ! kubectl get secret "${secret_name}" --namespace "{{ .Release.Namespace }}" &> /dev/null; then
                    echo "Secret for the node "{{ .Release.Name }}" does not exist. Creating..."
                    generate_nodekey "{{ .Values.node.role }}"
                    echo "sleep 2m" && sleep 1m
                    echo "sleep 2m done"
                    # add_node_to_genesis
                else
                    echo "Secret for the node "{{ .Release.Name }}" already exists."
                fi

      volumes:
        - name: package-manager
          configMap:
            name: package-manager
        # - name: scripts-volume
        #   configMap:
        #     name: bevel-vault-script
        #     defaultMode: 0777
